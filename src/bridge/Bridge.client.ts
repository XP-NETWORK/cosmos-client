/**
* This file was automatically generated by @cosmwasm/ts-codegen@0.35.7.
* DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
* and run the @cosmwasm/ts-codegen generate command to regenerate this file.
*/

import { CosmWasmClient, SigningCosmWasmClient, ExecuteResult } from "@cosmjs/cosmwasm-stargate";
import { Coin, StdFee } from "@cosmjs/amino";
import { Binary, Addr, InstantiateMsg, ExecuteMsg, AddValidatorMsg, SignerAndSignature, ClaimValidatorRewardsMsg, Lock721Msg, ClaimMsg, ClaimData, VerifyMsg, QueryMsg, GetCollectionDeployerResponse, GetStorageResponse, GetDuplicateToOriginalResponse, DuplicateToOriginalContractInfo, GetOriginalToDuplicateResponse, OriginalToDuplicateContractInfo, GetStorageDeployerResponse, GetValidatorResponse, Validator, GetValidatorCountResponse } from "./Bridge.types";
export interface BridgeReadOnlyInterface {
  contractAddress: string;
  getValidatorsCount: () => Promise<GetValidatorCountResponse>;
  getValidator: ({
    address
  }: {
    address: Binary;
  }) => Promise<GetValidatorResponse>;
  getCollectionDeployer: () => Promise<GetCollectionDeployerResponse>;
  getStorageDeployer: () => Promise<GetStorageDeployerResponse>;
  getOriginalStorage721: ({
    chain,
    contractAddress
  }: {
    chain: string;
    contractAddress: string;
  }) => Promise<GetStorageResponse>;
  getDuplicateStorage721: ({
    chain,
    contractAddress
  }: {
    chain: string;
    contractAddress: string;
  }) => Promise<GetStorageResponse>;
  getOriginalToDuplicate: ({
    chain,
    contractAddress
  }: {
    chain: string;
    contractAddress: string;
  }) => Promise<GetOriginalToDuplicateResponse>;
  getDuplicateToOriginal: ({
    chain,
    contractAddress
  }: {
    chain: string;
    contractAddress: Addr;
  }) => Promise<GetDuplicateToOriginalResponse>;
}
export class BridgeQueryClient implements BridgeReadOnlyInterface {
  client: CosmWasmClient;
  contractAddress: string;

  constructor(client: CosmWasmClient, contractAddress: string) {
    this.client = client;
    this.contractAddress = contractAddress;
    this.getValidatorsCount = this.getValidatorsCount.bind(this);
    this.getValidator = this.getValidator.bind(this);
    this.getCollectionDeployer = this.getCollectionDeployer.bind(this);
    this.getStorageDeployer = this.getStorageDeployer.bind(this);
    this.getOriginalStorage721 = this.getOriginalStorage721.bind(this);
    this.getDuplicateStorage721 = this.getDuplicateStorage721.bind(this);
    this.getOriginalToDuplicate = this.getOriginalToDuplicate.bind(this);
    this.getDuplicateToOriginal = this.getDuplicateToOriginal.bind(this);
  }

  getValidatorsCount = async (): Promise<GetValidatorCountResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_validators_count: {}
    });
  };
  getValidator = async ({
    address
  }: {
    address: Binary;
  }): Promise<GetValidatorResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_validator: {
        address
      }
    });
  };
  getCollectionDeployer = async (): Promise<GetCollectionDeployerResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_collection_deployer: {}
    });
  };
  getStorageDeployer = async (): Promise<GetStorageDeployerResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_storage_deployer: {}
    });
  };
  getOriginalStorage721 = async ({
    chain,
    contractAddress
  }: {
    chain: string;
    contractAddress: string;
  }): Promise<GetStorageResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_original_storage721: {
        chain,
        contract_address: contractAddress
      }
    });
  };
  getDuplicateStorage721 = async ({
    chain,
    contractAddress
  }: {
    chain: string;
    contractAddress: string;
  }): Promise<GetStorageResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_duplicate_storage721: {
        chain,
        contract_address: contractAddress
      }
    });
  };
  getOriginalToDuplicate = async ({
    chain,
    contractAddress
  }: {
    chain: string;
    contractAddress: string;
  }): Promise<GetOriginalToDuplicateResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_original_to_duplicate: {
        chain,
        contract_address: contractAddress
      }
    });
  };
  getDuplicateToOriginal = async ({
    chain,
    contractAddress
  }: {
    chain: string;
    contractAddress: Addr;
  }): Promise<GetDuplicateToOriginalResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_duplicate_to_original: {
        chain,
        contract_address: contractAddress
      }
    });
  };
}
export interface BridgeInterface extends BridgeReadOnlyInterface {
  contractAddress: string;
  sender: string;
  addValidator: ({
    data
  }: {
    data: AddValidatorMsg;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  claimValidatorRewards: ({
    data
  }: {
    data: ClaimValidatorRewardsMsg;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  lock721: ({
    data
  }: {
    data: Lock721Msg;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  claim721: ({
    data
  }: {
    data: ClaimMsg;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
  verifySig: ({
    data
  }: {
    data: VerifyMsg;
  }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
}
export class BridgeClient extends BridgeQueryClient implements BridgeInterface {
  client: SigningCosmWasmClient;
  sender: string;
  contractAddress: string;

  constructor(client: SigningCosmWasmClient, sender: string, contractAddress: string) {
    super(client, contractAddress);
    this.client = client;
    this.sender = sender;
    this.contractAddress = contractAddress;
    this.addValidator = this.addValidator.bind(this);
    this.claimValidatorRewards = this.claimValidatorRewards.bind(this);
    this.lock721 = this.lock721.bind(this);
    this.claim721 = this.claim721.bind(this);
    this.verifySig = this.verifySig.bind(this);
  }

  addValidator = async ({
    data
  }: {
    data: AddValidatorMsg;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      add_validator: {
        data
      }
    }, fee, memo, _funds);
  };
  claimValidatorRewards = async ({
    data
  }: {
    data: ClaimValidatorRewardsMsg;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      claim_validator_rewards: {
        data
      }
    }, fee, memo, _funds);
  };
  lock721 = async ({
    data
  }: {
    data: Lock721Msg;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      lock721: {
        data
      }
    }, fee, memo, _funds);
  };
  claim721 = async ({
    data
  }: {
    data: ClaimMsg;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      claim721: {
        data
      }
    }, fee, memo, _funds);
  };
  verifySig = async ({
    data
  }: {
    data: VerifyMsg;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, _funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      verify_sig: {
        data
      }
    }, fee, memo, _funds);
  };
}